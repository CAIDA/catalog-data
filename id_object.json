{
    "group:asrank": {
        "id": "group:asrank",
        "name": "AS Rank",
        "description": "A Ranking of the Internet's Automous Systems",
        "tags": [
            "tag:topology",
            "tag:security",
            "tag:software_tools"
        ],
        "availability": [
            {
                "format": "PDF",
                "url": "https://www.caida.org/publications/presentations/2019/network_hygiene_incentives_regulation_ccs/network_hygiene_incentives_regulation_ccs.pdf"
            }
        ],
        "filename": "sources/group/asrank.json",
        "__typename": "Group",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "license:bsd_4_clause_uc": {
        "id": "license:bsd_4_clause_uc",
        "name": "BSD-4-Clause (University of California-Specific)",
        "url": "https://spdx.org/licenses/BSD-4-Clause-UC.html",
        "filename": "sources/license/bsd_4_clause_uc.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:netacuity": {
        "id": "license:netacuity",
        "name": "Netacuity",
        "filename": "sources/license/netacuity.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:pyasn": {
        "id": "license:pyasn",
        "name": "pyasn",
        "filename": "sources/license/pyasn.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "solution:map_ipv4_address_to_asn": {
        "id": "solution:map_ipv4_address_to_asn",
        "name": "How to find the origin ASN for a IPv4 address with Python?",
        "descriptions": "The following solution uses libipmeta's `PyIPMeta` to map between ipv4 addresses and origin asns.",
        "tags": [
            "tag:measurement_methodology",
            "tag:topology",
            "tag:software_tools",
            "tag:asn",
            "tag:ipv4",
            "tag:ipv4_prefix"
        ],
        "content": "<h3>PyIPMeta</h3>\n\n<p>PyIPMeta is a Python library that provides a high-level interface for historical and realtime geolocation metadata lookups using Maxmind GeoIP and/or NetAcuity (Digital Element) geolocation databases.</p>\n\n<h4>Pre-requisites</h4>\n\n<p>Before installing PyIPMeta, you will need:\\\n\u2022 <a href=\"https://github.com/CAIDA/libipmeta\">libipmeta(&gt;= 3.0.0)</a>\\\n\u2022 Python setuptools (<code>sudo apt install python-setuptools</code> on Ubuntu) \\\n\u2022 Python development headers (<code>sudo apt install python-dev</code> on Ubuntu)</p>\n\n<p>Detailed installation and usage instructions <a href=\"https://github.com/CAIDA/pyipmeta \">here</a>.</p>\n\n<h1>solution</h1>\n\n<p>The following script returns a dictionary <code>ip2asn</code> that maps ips to origin asns. </p>\n\n<h3>Map between ips and origin asns using PyIPMeta</h3>\n\n<p>For this solution, clone <strong>PyIPMeta</strong> from <a href=\"https://github.com/CAIDA/pyipmeta\">here</a>\\\nMore data can be found at http://data.caida.org/datasets/routing/routeviews-prefix2as/</p>\n\n<p>Sample ips.txt found <a href=\"http://data.caida.org/datasets/topology/ark/ipv4/dns-names/2019/05/dns-names.l7.20190501.txt.gz\">here</a></p>\n\n<p><strong>Usage</strong> : <code>$ python3 ip_asn.py -i ips.txt</code></p>\n\n<p>~~~python\nimport _pyipmeta \nimport argparse</p>\n\n<p>parser = argparse.ArgumentParser()\nparser.add<em>argument('-i', dest = 'ips</em>file', default = '', help = 'Please enter the file name of the ips file')\nargs = parser.parse_args()</p>\n\n<p>ipm = _pyipmeta.IpMeta()</p>\n\n<h1>print(\"Getting/enabling pfx2as provider (using included test data)\")</h1>\n\n<p>prov = ipm.get<em>provider</em>by<em>name(\"pfx2as\")\nprint(ipm.enable</em>provider(prov, \"-f http://data.caida.org/datasets/routing/routeviews-prefix2as/2017/03/routeviews-rv2-20170329-0200.pfx2as.gz\"))\nprint()</p>\n\n<h1>Create list of ips from test file</h1>\n\n<p>ips = []\nwith open(args.ips_file) as f:\n    for line in f:\n        line = line.rstrip().split(\"\\t\")[1]\n        ips.append(line)</p>\n\n<h1>Map between ipv4 addresses and origin asns</h1>\n\n<p>ip2asn = {}\nfor ip in ips:\n    if ipm.lookup(ip):\n        (res,) =  ipm.lookup(ip)\n        if res.get('asns'):\n            ip2asn[ip] = res.get('asns')[-1]</p>\n\n<h1>print(ip2asn)</h1>\n\n<p>~~~</p>\n\n<h3><ins> Background </ins></h3>\n\n<p><strong>What is an IPv4 address prefix?</strong> \\\n\u2022 An <em>IP address</em> is a 32-bit unique address that is used to recognize a computer network or a machine. All computers on   the same data network share the same IP address.\\\n\u2022 An IPv4 address is typically written in decimal format as 4 8-bit fields separated by a period. Eg. 182.24.0.0/18 \\\n\u2022 An <em>IPv4 address prefix</em> is the prefix of an IPv4 address. \\\n\u2022 e.g. Consider the IPV4 address : 182.24.0.0/18 \\\n\u2022 In this case, 18 is the length of the prefix. \\\n\u2022 The prefix is the first 18 bits of the IP address. \\\n\u2022 More information on IPv4 addresses can be found <a href=\"https://docs.oracle.com/cd/E19455-01/806-0916/6ja85399u/index.html#:~:text=The%20IPv4%20address%20is%20a,bit%20fields%20separated%20by%20periods \">here</a></p>\n\n<p><strong>What is forwarding/How does forwarding work?</strong> \\\n\u2022 Fowarding means sending incoming information packets to the appropriate destination interface. This is done by routers with the help of a forwarding table. \\\n\u2022 Routers scan the destination IP prefix and locate a match using a forwarding table to determine the packet's next hop. \\\n\u2022 In cases of prefix overlap, where an incoming IP prefix map may match multiple IP entries in the table, the <em>Longest Prefix Matching Rule</em> is used to determine the next hop. </p>\n\n<p><strong>What is the Longest Prefix Matching Rule?</strong> \\\n\u2022 Longest Prefix Match is an algorithm to lookup the destination an IP prefix\u2019s next hop from the router. \\\nIt finds the prefix matching the given IP address and returns the corresponding router node.\\\n\u2022 The router which corresponds to the IP address with the longest matching prefix is selected as the destination router node.\\\n\u2022 Consider the following example:\n| IP Prefix        |   Router      |\n| -------------    | ------------- |\n| 192.168.20.16/28 | A             |\n| 192.168.0.0/16   | B             |</p>\n\n<p>\u2022 For example, for the given incoming IP address:  192.168.20.19 \\\n\u2022 <strong>Node A</strong> is selected as the destination router node as it contains the <em>longer matching prefix</em> i.e. 192.168.20.16 \\\n\u2022 Source: <a href=\"https://www.lewuathe.com/longest-prefix-match-with-trie-tree.html \">link</a> \\\n\u2022 More information can be found <a href=\"https://www.geeksforgeeks.org/longest-prefix-matching-in-routers/ \">here</a></p>\n\n<p><strong>What is an AS?</strong>\\\n \u2022 AS stands for Autonomous system.\\\n \u2022 It can be broadly be thought of as a single organization, or a collection of routers that route groups of IP addresses under a common administration, typically a large organization or an ISP (Internet Service Provider). \\\n \u2022 It is a connected group of one or more IP addresses (known as IP prefixes) that provide a common way to route internet traffic to systems outside the AS.\\\n \u2022 More information on AS can be found <a href=\"https://www.cs.rutgers.edu/~pxk/352/notes/autonomous_systems.html\">here</a> and <a href=\"https://www.caida.org/publications/presentations/2016/as_intro_topology_wind/as_intro_topology_wind.pdf\">here</a></p>\n\n<h3><ins> Caveats </ins></h3>\n\n<p>\u2022 <strong>Multi-origin AS</strong> : Some prefixes originate from multiple AS's (which could be siblings or distinct organizations).\\\nThis makes it more challenging to interpret the appearance of a matching destination IP address, as the address could be on a router operated by any one of the origin AS's.  \\\n\u2022 <strong>Third-party AS's</strong> \\\n\u2022 Border routers may use a third-party address when responding to traceroute probes. \\\n\u2022 A third-party address is an IP address corresponding to an AS that is not on the path toward a destination.</p>\n\n<h3><ins> Note: </ins></h3>\n\n<p>\u2022 <code>pyasn</code> can also be used for mapping between ipv4 addresses and origin asns.\\\n\u2022 The <code>pyasn</code> object is be initialized using an IPASN datafile. \\\n\u2022 It also provides extremely fast lookups for IP addresses, as it returns the origin asns and the BGP prefixes it matches.\\\n\u2022 Detailed installation instructions and more information on Usage and IPASN data files <a href=\"https://github.com/hadiasghari/pyasn \">found here</a>.\\\n\u2022 Note that the current <code>pyipmeta</code> <strong>does not support</strong> <code>ipv6</code>, whereas <code>pyasn</code> does. </p>\n\n<p>However, <code>pyipmeyta</code> provides <strong>greater flexbility</strong> as it provides the geographical information as well. </p>\n\n<p>For example, <code>ipm.lookup('192.172.226.97')</code> returns:</p>\n\n<p><code>[{'connection_speed': '', 'city': '', 'asn_ip_count': 0, 'post_code': '', 'lat_long': (37.750999450683594, -97.8219985961914), 'region': '', 'area_code': 0, 'asns': [], 'continent_code': 'NA', 'metro_code': 0, 'matched_ip_count': 1, 'region_code': 0, 'country_code': 'US', 'id': 223, 'polygon_ids': []}]</code></p>\n\n<p>\u2022 This object can then be parsed to map between IP addresses and origin asns. </p>\n",
        "context": "",
        "filename": "sources/solution/map_ipv4_address_to_asn/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:how_to_find_the_business_relationship_between_asns": {
        "id": "solution:how_to_find_the_business_relationship_between_asns",
        "visibility": "public",
        "name": "How to find the business relationship between asns",
        "description": "Using .as-rel file, or AS Rank to map a pair of given asns to their relationship.",
        "tags": [
            "tag:asn",
            "tag:as_relationship",
            "tag:as_rank",
            "tag:ipv4"
        ],
        "content": "<h2><strong><ins>Introduction</ins></strong></h2>\n\n<p>The following solution has two scripts. One script handles a <a href=\"pair_2_rel.py\">local input</a>, and one that <a href=\"api_2_rel.py\">uses AS Rank's API</a>. Both produce a dictionary, <code>pair_2_rel</code> which maps a pair of given asns to their relationship. The local file script has one flag: -r which takes in a path to a .as-rel file, this can be downloaded <a href=\"https://www.caida.org/data/as-relationships/\">here</a>. The api script has in input, and just calls the api until all as relationships have been found. This script is significantly slower compared to the local file version.</p>\n\n<h2>Usage</h2>\n\n<p>Below is an example of using the local file script to parse a .as-rel file to create a mapping between a pair of asns and their relationship. This file can take in either .txt or encoded .bz2 files.</p>\n\n<p><code>bash\npython3 pair_2_rel.py -r 20200101.as-rel.txt\n</code></p>\n\n<p>For the api version of the script, you'll need to import <a href=\"https://pypi.org/project/graphqlclient/#description\">graphqlclient</a>. Below is how to install the package:</p>\n\n<p><code>bash\npip3 install graphqlclient\n</code></p>\n\n<p>Below is an example of how to run the api script to create a mapping between as pairs and their relationships. </p>\n\n<p><code>bash\npython3 api_2_rel.py\n</code></p>\n\n<h2><strong><ins>Solution</ins></strong></h2>\n\n<p>Below is the helper method used to parse a given line of the .as-rel file in the <a href=\"pair_2_rel.py\">local file script</a>. This method updates the dictionary, <code>pair_2_rel</code> by sorting the two asns by value prior to mapping the pair to their relationship.</p>\n\n<p>~~~Python</p>\n\n<h1>Parse a given line of the as<em>rel</em>file and map two ASes to their relationship.</h1>\n\n<p>def parse<em>as</em>rel<em>line(curr</em>line):\n    global pair<em>2</em>rel\n    global rel<em>2</em>name</p>\n\n<pre><code># Edge Case: Skip any commented lines.\nif curr_line[0] == \"#\":\n    return\n\n# Get each piece of data from the current line.\nasn0, asn1, relationship = curr_line.split(\"|\")\n\n# Place both related AS's in par_2_rel based on value of ASes.\nif (asn0 &gt; asn1):\n    temp = asn0\n    asn0 = asn1\n    asn1 = temp\n    relationship = -1 * int(relationship)\n\n# Replace relationship with the string version of it's value.\nrelationship = rel_2_name[int(relationship)]\n\nkey = asn0 + \" \" + asn1\n\n# Add the pair's relationship if doesn't already exist.\nif key not in pair_2_rel:\n    pair_2_rel[key] = relationship\n</code></pre>\n\n<p>~~~</p>\n\n<p>Below are two helper methods used in the <a href=\"api_2_rel.py\">api script</a>. The first helper method is the AS Rank Query, and what data is taken from the API. The second helper method shows what is done with the data taken from the API. The second method assumes the input is a dictionary of the keys and values within the \"node\" section of the query's format. </p>\n\n<p>~~~Python</p>\n\n<h1>Helper method of the formatted query.</h1>\n\n<p>def as<em>links</em>query(first, offset):\n    return [\n        \"asnLinks\",\n        \"\"\"{\n        asnLinks(first:%s, offset:%s) {\n            totalCount\n            pageInfo {\n                first\n                hasNextPage\n            }\n            edges {\n                node {\n                    relationship\n                    asn0 {\n                        asn\n                    }\n                    asn1 {\n                        asn\n                    }\n                    numberPaths\n                }\n            } \n        }\n    }\"\"\"  % (first, offset)\n    ]</p>\n\n<h1>Helper method that takes in a dict to create a pair relationship.</h1>\n\n<p>def update<em>pair</em>2<em>rel(curr</em>line):\n    global pair<em>2</em>rel\n    global name<em>2</em>rel\n    global rel<em>2</em>name</p>\n\n<pre><code># Get the values from the current line.\nrelationship = name_2_rel[curr_line[\"relationship\"]]\nasn0 = int(curr_line[\"asn0\"][\"asn\"])\nasn1 = int(curr_line[\"asn1\"][\"asn\"])\n\n# Place both related AS's in par_2_rel based on value of ASes.\nif (asn0 &gt; asn1):\n    temp = asn0\n    asn0 = asn1\n    asn1 = temp\n    relationship = -1 * relationship\n\nkey = str(asn0) + \" \" + str(asn1)\n\n# Add the pair's relationship if doesn't already exist.\nif key not in pair_2_rel:\n    pair_2_rel[key] = rel_2_name[relationship]\n</code></pre>\n\n<p>~~~</p>\n\n<p>This helper method is offered to show how to easily access a relationship in pair<em>2</em>rel in either script. This method also shows how to format two given asns to match the key format of pair<em>2</em>rel. The commented out return line could be helpful for testing, or to better understand what the relationship between the ases mean.</p>\n\n<p>~~~Python</p>\n\n<h1>Helper function to format two given asns into a key for as<em>pair</em>2_rel.</h1>\n\n<p>def get<em>relationship(asn0, asn1):\n    global pair</em>2_rel</p>\n\n<pre><code>if (asn0 &gt; asn1):\n    temp = asn0\n    asn0 = asn1\n    asn1 = temp\n\nkey = str(asn0) + \" \" + str(asn1)\n\n# Return the relationship, or return None if the key isn't valid.\nif key in pair_2_rel:\n    rel = pair_2_rel[key]\n    return rel\n    # return str(asn0) + \"'s \" + str(rel) + \" is \" + str(asn1)\nelse:\n    return None\n</code></pre>\n\n<p>~~~</p>\n\n<h2><strong><ins>Background</ins></strong></h2>\n\n<h3>What is an AS Relationship</h3>\n\n<ul>\n<li>An AS Relationship is the determined routing policy between two ASes.</li>\n<li>The three most common types of AS Relationships are:\n<ul>\n<li>customer-to-provider (c2p) (or if looked at from the opposite direction,  provider-to-customer p2c),</li>\n<li>peer-to-peer (p2p),</li>\n<li>sibling-to-sibling (s2s)</li>\n</ul></li>\n<li>A p2p link connects two ISPs who have agreed to exchange traffic between each other and their customer's. This can allow growing ISPs savings on transit costs compared to c2p relationships.</li>\n<li>An s2s link connects two ASes with a common administrative boundary. Such links usually appear as a result of mergers and acquisitions, or under certain network management scenarios.</li>\n<li>More information on AS Relationships can be found <a href=\"https://www.caida.org/data/as-relationships/\">here</a></li>\n</ul>\n\n<p>~~~text\nas0 as1 rel\n10   2  -1     10's customer is 2 (p2c)\n10   3   0     10's peer is 3 (p2p)\n10   4   1     10's provider is 4 (c2p)\n~~~</p>\n\n<h3>What is the ASRank API?</h3>\n\n<ul>\n<li>ASRank is CAIDA's ranking of Autonomous Systems and organizations.</li>\n<li>This API uses GraphQL for API requests which can be seen in the <code>as_links_query(first, offset)</code> method.</li>\n<li>For more information on ASRank, click <a href=\"https://asrank.caida.org/\">here</a>.</li>\n<li>For more information on ASRank's API, click <a href=\"https://api.asrank.caida.org/v2/docs\">here</a>.</li>\n</ul>\n\n<h3>Caveats</h3>\n\n<p>A pair of asns is sorted by their values in ascending order. Ex: <code>10 15</code>, you'll never see a key formatted as: <code>15 10</code>. This reduces memory by ensuring two asns won't have both of their relationships in the dictionary. However this means the user has to sort the asns prior to accessing the data. This is why the helper method: <code>get_relationship(ans0, asn1)</code> is provided.</p>\n\n<h3>File Format: .as-rel</h3>\n\n<p>Below is an example of the possible lines found in a .as-rel file. For the purpose of this solution and script, we will ignore all line that start with \"#\" since they will not be needed.</p>\n\n<p>~~~text</p>\n\n<h1>source:topology|BGP|<data>|<system>|<monitor></h1>\n\n<p><asn0>|<asn1>|<relationship>\n~~~</p>\n",
        "context": "",
        "filename": "sources/solution/how_to_find_the_business_relationships_between_asns/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/06 23:55:08",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:how_to_parse_cymru_bogon_data": {
        "id": "solution:how_to_parse_cymru_bogon_data",
        "name": "How to Parse CYMRU Bogan Data",
        "description": "The following solution will output whether an IP address is bogon",
        "tags": [
            "tag:bogon",
            "tag:bogon_address",
            "tag:ip_address",
            "tag:ip"
        ],
        "content": "<h2>Solution</h2>\n\n<p>This solution requires pyasn: <a href=\"https://github.com/hadiasghari/pyasn\">pyasn github</a></p>\n\n<p>bogon_load() takes in one input:\n- <code>path</code>: path to the bogon dataset found here: https://www.caida.org/data/bogons/ </p>\n\n<p>bogon<em>check</em>ip() takes in two inputs:\n- <code>ips</code>: a list of IP addresses\n- <code>bogondb</code>: the result from bogon_load()</p>\n\n<p><strong>Usage:</strong> <code>python3 bogon.py [bogon dataset] [ip address] [ip address]....</code></p>\n\n<p>i.e.<code>python3 bogon.py 2020-05-13.fullbogons-ipv4.txt 0.0.0.1 10 5.44.248.1 1.1.1.1</code> yields \n~~~\nInvalid IP:  10\n[True, False, True, False]\n~~~</p>\n\n<p><strong>Code:</strong>\n~~~python\nimport pyasn\nimport numpy as np\nimport os</p>\n\n<p>def bogon<em>load(path):\n    \"\"\"\n    Loads bogon dataset into memory.\n    \"\"\"\n    temp</em>file = \"<em>bogon.dat\"\n    f = open(path, \"r\")\n    ips = []\n    next(f)\n    for line in f.readlines():\n        ips.append(line.replace('\\n',\"\") + \"\\t1\")\n    hdrtxt = '; IP-ASN32-DAT file\\n; Original file : <Path to a rib file>\\n; Converted on  : temp\\n; CIDRs         : 512490\\n;'\n    np.savetxt(temp</em>file, ips, header=hdrtxt,fmt='%s')\n    bogondb = pyasn.pyasn('<em>bogon.dat')\n    os.remove(temp</em>file)\n    return bogondb</p>\n\n<p>def bogon<em>check</em>ip(ips, bogondb):\n    \"\"\"\n    Checks whether a given IP address is bogon\n    \"\"\"\n    is_bogon = [False]*len(ips)\n    for index in range(len(ips)):\n        # Check if IP is valid\n        try:\n            bogondb.lookup(ips[index])\n        except ValueError:\n            print(\"Invalid IP: \", ips[index])\n            continue</p>\n\n<pre><code>    # Look up IP\n    if bogondb.lookup(ips[index])[1]:\n        is_bogon[index] = True\n    else:\n        continue\nprint(is_bogon)\n</code></pre>\n\n<p>~~~</p>\n\n<h2>Background</h2>\n\n<h3>What is an IP address?</h3>\n\n<ul>\n<li>IP addresses are unique 32-bit numbers allocated to identify devices in the Internet Protocol</li>\n<li>An address is allocated to entities by an organization named IANA and organizations named RIRs</li>\n</ul>\n\n<h3>What is a Bogon IP Address?</h3>\n\n<ul>\n<li>Bogon addresses have not been allocated by IANA or any of the RIRs</li>\n<li>These addresses congregate to make up what is known as \"bogus space\"</li>\n<li>This space includes reserved space</li>\n<li>Make sure to download the latest bogon file, because the ranges are subject to change</li>\n</ul>\n\n<h3>What is pyasn?</h3>\n\n<ul>\n<li>pyasn is a package that allows for very quick lookups of addresses</li>\n<li>We've made a temporary file that allows us to quickly look up whether an IP address is within a bogon prefix</li>\n</ul>\n",
        "context": "",
        "filename": "sources/solution/how_to_parse_cymru_bogon_data/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:solution_how_to_find_an_asns_customer_cone": {
        "id": "solution:solution_how_to_find_an_asns_customer_cone",
        "visibility": "public",
        "name": "How to find an ASNs customer cone",
        "description": "The following solution will help the user create a Python dictionary where the key is a given asn, and the values are the asn, it's customer cone, and customer cone size. This solution and script is usable for IPv4.",
        "tags": [
            "tag:asn",
            "tag:as_relationships",
            "tag:customer_cone",
            "tag:ipv4",
            "tag:topology"
        ],
        "content": "<p>The following <a href=\"as-customer-cone.py\">script</a> produces a dictionary as<em>2</em>cone that maps an ASN to it's customer cone and size. The script has one flag: -p (.ppdc-ases) since you'll only need to provide a .ppdc-ases file in either a .txt or encoded .bz2 format.</p>\n\n<p>~~~json\n{\n    \"asn0\" : {\n        \"asn\" : \"asn0\",\n        \"cone\" : [ \"asn0\", \"asn1\", \"...\", \"asnM\" ],\n        \"size\" : 0\n    },\n}\n~~~</p>\n\n<h3>Usage</h3>\n\n<p>The dataset that is used for this script can be downloaded <a href=\"https://www.caida.org/data/as-relationships/\">here</a>. Below is an example of running the script to get IPv4 customer cones from January 1, 2020. Reminder, this script can handle both .txt and .bz2 files.</p>\n\n<p>~~~bash\npython3 as-customer-cone.py -p 20200101.ppdc-ases.txt\n~~~</p>\n\n<p>Below is the helper method the script uses to parses the .ppdc-ases file line-by-line to update as<em>2</em>cone with a mapping between a given asn, its cone, and cone size.</p>\n\n<p>~~~Python</p>\n\n<h1>Given an line of a .ppdc-ases file, get the asn and its Customer Cone.</h1>\n\n<p>def parse<em>ppdc</em>ases<em>line(curr</em>line):\n    global as<em>2</em>cone</p>\n\n<pre><code># Edge Case: Skip any commented lines.\nif curr_line[0] == \"#\":\n    return\n\ncustomer_cone = curr_line.split()\nasn = int(customer_cone[0])\ncustomer_cone_size = len(customer_cone[1:])\n\n# Update as_2_cone with this asn's customer_cone_size.\nif asn not in as_2_cone:\n    as_2_cone[asn] = {}\n\nas_2_cone[asn][\"asn\"] = asn\nas_2_cone[asn][\"cone\"] = customer_cone\nas_2_cone[asn][\"size\"] = customer_cone_size[1:]\n</code></pre>\n\n<p>~~~</p>\n\n<h2><strong><ins>Background</ins></strong></h2>\n\n<h3>What is an AS</h3>\n\n<ul>\n<li>AS stands for Autonomous system</li>\n<li>It can be broadly be thought of as a single organization, or a collection of routers that route groups of IP addresses under a common administration, typically a large organization or an ISP (Internet Service Provider).</li>\n<li>It is a connected group of one or more IP addresses (known as IP prefixes) that provide a common way to route internet traffic to systems outside the AS.</li>\n<li>Each AS is responsible for routing traffic within itself. This is known as intra-AS routing.</li>\n<li>Each AS can also route traffic between itself and other autonomous systems. This is known as inter-AS routing.</li>\n<li>More information on AS can be found <a href=\"https://www.cs.rutgers.edu/~pxk/352/notes/autonomous_systems.html\">here</a> and <a href=\"https://www.caida.org/publications/presentations/2016/as_intro_topology_wind/as_intro_topology_wind.pdf\">here</a></li>\n</ul>\n\n<h3>What is an ASN</h3>\n\n<ul>\n<li>Each AS is assigned a unique ASN, or <em>Autonomous System Number</em> that allows it to be uniquely identified during routing.</li>\n</ul>\n\n<h3>What is an AS Relationship</h3>\n\n<ul>\n<li>An AS Relationship is the determined routing polocy between two ASes.</li>\n<li>The three most commo types of AS Relationships are:\n<ul>\n<li>customer-to-provider (c2p) (or if looked at from the opposite direction,  provider-to-customer p2c),</li>\n<li>peer-to-peer (p2p),</li>\n<li>sibling-to-sibling (s2s)</li>\n</ul></li>\n<li>A p2p link connect two ISPs who have agreed to exchange traffic between each other and their customer's. This can allow growing ISPs savings on transit costs compared to c2p relationships.</li>\n<li>An s2s link connects two ASes with a common administrative boundary. Such links usually appear as a result of mergers and acquisitions, or under certain network management scenarios.</li>\n<li>More information on AS Relationships can be found <a href=\"https://www.caida.org/data/as-relationships/\">here</a></li>\n</ul>\n\n<h3>What is a Customer Cone</h3>\n\n<ul>\n<li>A customer cone is the set of ASes, prefixes, or addresses that can be reached from a given AS following only customer links.</li>\n<li>An AS A's AS customer cone as the AS A itself plus all the ASes that can be reached from A following only p2c links in BGP paths we observed.\n<ul>\n<li>In other words, A's customer cone contains A, plus A's customers, plus its customers' customers, and so on.</li>\n</ul></li>\n<li>The size of the customer cone of an AS reflects the number of other elements (ASes,  prefixes, or addresses) found in it's set.</li>\n<li>An AS in the customer cone is assumed to pay, directly or indirectly, for transit, and provides a coarse metric of the size or influence of an AS in the routing system.</li>\n</ul>\n\n<h3>File Format: .ppdc-ases</h3>\n\n<p>For the purpose of this solution, we'll be skipping over any commented lines. Each line is a customer cone where asn0 is the \"head\" of the cone and all asns after is are within its cone.</p>\n\n<p>~~~text</p>\n\n<h1>inferred clique:</h1>\n\n<h1>total size: ...</h1>\n\n<p><asn0>|<asn1>|...|<asnM>\n~~~</p>\n",
        "context": "",
        "filename": "sources/solution/how_to_find_an_asns_customer_cone/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/06 23:55:08",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:how_to_get_range_of_allocated_or_reserved_ips": {
        "id": "solution:how_to_get_range_of_allocated_or_reserved_ips",
        "name": "How to get the range of allocated or reserved IPs?",
        "description": "The following solution will create two dictionaries listing the designations of IP addresses, one compressed with out specific designations, one with designations.",
        "question": "How to get the range of reserved and allocated ASNs",
        "tags": [
            "tag:ipv4",
            "tag:iana",
            "tag:ip_address",
            "tag:ip"
        ],
        "content": "<h2>Solution</h2>\n\n<p>This solution will return two dictionaries - one compressed (with only allocated, legacy, and reserved keys) and one with specific /8 IP designations. </p>\n\n<p><strong>Usage</strong>: </p>\n\n<p>You can either enter a path to the current IANA IPv4 csv.</p>\n\n<p>This link will download the latest available IPv4 space registry:\nhttps://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.csv</p>\n\n<p><code>python3 parse_ipv4.py [path to csv]</code></p>\n\n<p>~~~python\nimport pandas as pd\nimport sys\nimport more_itertools as mit</p>\n\n<p>def parse<em>ip</em>assignees(csv<em>path):\n    ip = pd.read</em>csv(csv<em>path).reset</em>index()\n    ip[\"Designation\"] = ip[\"Designation\"].apply(lambda x: x.lower().replace(\"administered by\", \"\").strip())</p>\n\n<pre><code>consec = (lambda x: [list(group) for group in mit.consecutive_groups(list(x))])\n\nip = (ip.drop(ip.columns.difference([\"index\",\"Designation\"]), axis=1)\n.groupby([\"Designation\"])[\"index\"]\n.apply(lambda x: [[y[0], y[-1]] for y in consec(x)])\n.to_dict())\nreturn ip\n</code></pre>\n\n<p>def parse<em>ip</em>compressed(csv<em>path):\n    ip = pd.read</em>csv(csv<em>path).reset</em>index()\n    ip[\"Status [1]\"] == ip[\"Status [1]\"].apply(lambda x: x.lower())</p>\n\n<pre><code>consec = (lambda x: [list(group) for group in mit.consecutive_groups(list(x))])\n\nip = (ip.drop(ip.columns.difference([\"index\",\"Status [1]\"]), axis=1)\n.groupby([\"Status [1]\"])[\"index\"]\n.apply(lambda x: [[y[0], y[-1]] for y in consec(x)])\n.to_dict())\nreturn ip\n</code></pre>\n\n<p>print(parse<em>ip</em>assignees(sys.argv[1]), parse<em>ip</em>compressed(sys.argv[1]))\n ~~~</p>\n\n<p>## Background</p>\n\n<p>### What is an IP address?</p>\n\n<ul>\n<li>An IP address is a fundamental concept in the Internet Protocol</li>\n<li>They are uniquely assigned labels assigned to devices in order route information to and from other devices in the network</li>\n<li><p>Each IP address is 32-bits, separated into four 8-bit numbers</p>\n\n<h3>What is a /8 address?</h3></li>\n<li><p>The first 8-bits of the IP address</p></li>\n<li><p>Least specific; most /8 addresses are assigned to RIRs, or Regional Internet Registries, who allocate IP addresses to organizations in their respective regions</p>\n\n<h3>What do the compressed designations mean?</h3></li>\n<li><p><strong>Legacy</strong>: Either assigned to an organization or administered by an RIR. Legacy is used for blocks that have been assigned before the establishment of the RIRs.</p></li>\n<li><strong>Allocated</strong>: Allocated to an RIR</li>\n<li><p><strong>Reserved</strong>: Reserved for special purposes</p>\n\n<h2>Caveats</h2></li>\n<li><p>This has been made specifically for the current IANA file</p></li>\n</ul>\n",
        "context": "",
        "filename": "sources/solution/how_to_get_range_of_allocated_or_reserved_ips/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:parse_the_itdk": {
        "name": "Parse CAIDA's ITDK for a router's IPs, ASN, neighbors, and geographic location.",
        "description": "Using the ASN's organizatoin's country in WHOIS to map an ASN to the country of it's headquarters.",
        "tags": [
            "tag:measurement_methodology",
            "tag:topology",
            "tag:software_tools",
            "tag:asn",
            "tag:geolocation"
        ],
        "id": "solution:parse_the_itdk",
        "content": "<h2><strong><ins> Introduction </ins></strong></h2>\n\n<p>This solution parses through ITDK datasets and stores a node's <code>node id</code>, <code>isp</code>, <code>asn</code> and <code>location</code> as a json object. \\\nThe relevant <code>node</code> information is extracted from 4 different files: \\\n\u2022 <code>node id</code> and <code>isp</code> from <strong>nodes.bz2</strong> \\\n\u2022 <code>asn</code> from <strong>nodes.as.bz2</strong> \\\n\u2022 <code>neighbors</code> from <strong>links.bz2</strong> \\\n\u2022 <code>location</code> from <strong>nodes.geo.bz2</strong></p>\n\n<h2><strong><ins> Solution </ins></strong></h2>\n\n<p>The following script combines the information across the four files into a dictionary of nodes with the following structure:\n~~~json\n{\n    \"id\":4,\n    \"asn\":123,\n    \"isp\":[\"12.3.34\"],\n     \"neighbors\":{\"3,2,3\"},\n    \"location\":{\n        \"continent\":\"SA\",\n        \"country\":\"CO\",\n        \"region\":\"34\",\n        \"city\": \"Bogota\"\n     },\n     \"links\": [\n        {\"to\":\"dataset:internet<em>topology</em>data_kit\"}\n    ]\n}\n~~~</p>\n\n<p><strong>usage</strong>: <code>parse_ark.py -n nodes.bz2 -l links.bz2 -a nodes.as.bz2 -g nodes.geo.bz2</code></p>\n\n<p>~~~python\nimport argparse\nimport bz2\nimport socket\nimport struct</p>\n\n<p>parser = argparse.ArgumentParser()\nparser.add<em>argument('-n', dest = 'node</em>file', default = '', help = 'Please enter the file name of Nodes File')\nparser.add<em>argument('-l', dest = 'link</em>file', default = '', help = 'Please enter the file name of Links File')\nparser.add<em>argument('-a', dest = 'nodeas</em>file', default = '', help = 'Please enter the file name of Node-AS File')\nparser.add<em>argument('-g', dest = 'geo</em>file', default = '', help = 'Please enter the file name of Node<em>Geolocation File')\nargs = parser.parse</em>args()</p>\n\n<h1>create dictionary</h1>\n\n<p>nodes = {}\nMASK<em>8 = struct.unpack(\"!I\", socket.inet</em>aton(\"255.0.0.0\"))[0]\nPREFIX<em>224 = struct.unpack(\"!I\", socket.inet</em>aton(\"224.0.0.0\"))[0]\nMASK<em>3 = PREFIX</em>224\nPREFIX<em>0 = struct.unpack(\"!I\", socket.inet</em>aton(\"0.0.0.0\"))[0]</p>\n\n<p>def node_lookup(nid):\n    \"\"\"\n    To check whether nid is in the ndoes.\n    If not, create one in nodes.</p>\n\n<pre><code>param: string, input node id\n\"\"\"\nif nid not in nodes:\n    nodes[nid] = {\n        \"id\": \"\",\n        \"asn\": \"\",\n        \"isp\": [],\n        \"neighbors\": set(),\n        \"location\": {\n            \"continent\": \"\",\n            \"country\": \"\",\n            \"region\": \"\",\n            \"city\": \"\"\n            }\n    }\nreturn nodes[nid]\n</code></pre>\n\n<p>def placeholder_lookup(addr):\n    \"\"\"\n    To check whether the node is a placeholder or not\n    If the addr is in 224.0.0.0 or 0.0.0.0, then it is a placeholder</p>\n\n<pre><code>param:\naddr: string, input IPv4 addresss\n\"\"\"\nbinary_addr = struct.unpack(\"!I\", socket.inet_aton(addr))[0]\n\nif (binary_addr &amp; MASK_3) != PREFIX_224 and (binary_addr &amp; MASK_8) != PREFIX_0:    \n    return False\nelse:\n    return True\n</code></pre>\n\n<h1>=== load nodes.bz2 ===</h1>\n\n<p>with bz2.open(args.node_file, mode='r') as f:</p>\n\n<pre><code>for line in f:\n\n    # convert byte string to string\n    line = line.decode() \n\n    # skip the comments or the length of line is zero\n    if len(line) == 0 or line[0] == \"#\":\n        continue\n\n    value = line.strip(\" \\n\") # remove tailing newline\n    value = value.split(\" \")\n    value[1] = value[1].replace(\":\", \"\") # value[1] == nid\n\n    # get isp and check whether the node is placeholder\n    isp_list = []\n    placeholder = False\n\n    for isp in value[2:]:\n        if len(isp) == 0:\n            continue\n        if placeholder_lookup(isp):\n            placeholder = True           \n        isp_list.append(isp)\n\n    # if the node the not placeholder, then process the node\n    if not placeholder:\n        node = node_lookup(value[1])\n        node['id'] = value[1].replace(\"N\", \"\")\n        node['isp'] = isp_list\n</code></pre>\n\n<h1>=== load nodes.as.bz2 ===</h1>\n\n<p>with bz2.open(args.nodeas_file, mode = 'r') as f:\n    for line in f:\n        line = line.decode()\n        value = line.split(\" \")</p>\n\n<pre><code>    # if the node is in nodes, assign AS number to each node\n    if value[1] in nodes:\n        nodes[value[1]][\"asn\"] = value[2]\n</code></pre>\n\n<h1>=== load nodes.geo.bz2 file ===</h1>\n\n<p>with bz2.open(args.geo_file, 'r') as f:\n    for line in f:\n        line = line.decode()</p>\n\n<pre><code>    # skip over comments\n    if len(line) == 0 or line[0] == \"#\":\n        continue\n\n    value = line.split(\" \")\n    value[1] = value[1].split(\"\\t\")\n    value[1][0] = value[1][0].replace(\":\", \"\")\n\n    # if the node is in nodes, assign geo info to each node\n    if value[1][0] in nodes:\n        node = nodes[value[1][0]]\n        node[\"location\"][\"continent\"] = value[1][1]\n        node[\"location\"][\"country\"] = value[1][2]\n        node[\"location\"][\"region\"] = value[1][3]\n        node[\"location\"][\"city\"] = value[1][4]\n</code></pre>\n\n<h1>=== load links.bz2 file ===</h1>\n\n<p>with bz2.open(args.link_file, 'r') as f:\n    for line in f:\n        line = line.decode()</p>\n\n<pre><code>    # skip over comments of the length of line is zero\n    if len(line) == 0 or line[0] == \"#\":\n        continue\n\n    value = line.strip(\" \\n\")\n    value = value.split(\" \")\n\n    neighbors = []\n    for nid in value[3:]:\n        neighbors.append(nid.split(\":\")[0])\n\n    for nid in neighbors:\n        if nid in nodes:\n            for n in neighbors:\n\n                #skip its neighbors are the node itself \n                if nid == n or n not in nodes:\n                    continue\n\n                nodes[nid][\"neighbors\"].add(n)\n                nodes[n][\"neighbors\"].add(nid)\n</code></pre>\n\n<p>~~~</p>\n\n<h3>Placeholder Perl Code</h3>\n\n<p>This Perl code parse nodes.bz2 file only.\n~~~Perl</p>\n\n<h1>! A/opt/local/bin/perl</h1>\n\n<h1>Many nodes in the ITDK are placeholder nodes.</h1>\n\n<h1>this are the non response hops in the traceroute</h1>\n\n<h1>12.0.0.1  * 123.3.2.3</h1>\n\n<h1>We don't know what machine is there, but we know there is a machine between</h1>\n\n<h1>12.0.0.1 and 123.3.2.3.</h1>\n\n<h1>In most analysis, we want to ignore placeholders.</h1>\n\n<h1>You identify placeholders by their IP addresses.</h1>\n\n<h1>Placeholder nodes have reserved IP addresses</h1>\n\n<h1>The following Perl code identifies placeholders</h1>\n\n<p>use warnings;\nuse strict;</p>\n\n<p>use Socket qw(PF<em>INET SOCK</em>STREAM pack<em>sockaddr</em>in inet_aton);</p>\n\n<p>use constant MASK<em>3 =&gt; unpack(\"N\",inet</em>aton(\"224.0.0.0\"));\nuse constant PREFIX<em>224 =&gt; MASK</em>3;\nuse constant MASK<em>8 =&gt; unpack(\"N\",inet</em>aton(\"255.0.0.0\"));\nuse constant PREFIX<em>0 =&gt; unpack(\"N\",inet</em>aton(\"0.0.0.0\"));</p>\n\n<p>my $nodes<em>total = 0;\nmy $placeholder</em>total = 0;</p>\n\n<p>while (&lt;&gt;) {\n    next if (/#/);\n    my ($node,$nid,@addrs) = split /\\s+/;\n    my $placeholder;\n    foreach my $addr (@addrs) {\n        my $net = inet<em>aton($addr);\n        my $binary = unpack(\"N\", $net);\n        if ((($binary &amp; MASK</em>3) == PREFIX<em>224)\n            || (($binary &amp; MASK</em>8) == PREFIX<em>0)) {\n            $placeholder = 1;\n            last;\n        }\n    }\n    if (not $placeholder) {\n        $nodes</em>total += 1;\n    } else {\n        $placeholder_total += 1;\n    }</p>\n\n<pre><code>#print (\"$not_place_holder_node $nodes_total $placeholder_total\\n\");\n# Only process the none placeholder nodes\n#last if ($nodes_total &gt; 10);\n</code></pre>\n\n<p>}</p>\n\n<p>print (\"nodes<em>total: \",$nodes</em>total,\"\\n\");\nprint (\"placeholder: \",$placeholder_total,\"\\n\");\n~~~</p>\n\n<h2><strong><ins> Background </ins></strong></h2>\n\n<h3>Caveats</h3>\n\n<p>#### Placeholder Nodes ###</p>\n\n<p>\u2022 Placeholder nodes are the non-response hops in the traceroute. \\\n\u2022 Generally, placeholder nodes are ignored. \\\n\u2022 Placeholder nodes have reserved IP addresses used to identify them. For the ITDK dataset, we use addresses <code>224.0.0.0</code> and <code>0.0.0.0</code> as the placeholder addresses.</p>\n\n<h3>Explanation of the Data Files</h3>\n\n<p><em>Download ITDK Datasets:</em> <a href=\"https://www.caida.org/data/request_user_info_forms/ark.xml\">link</a></p>\n\n<h4>midar-iff.nodes.bz2</h4>\n\n<p>The nodes file lists the set of interfaces that were inferred to be on each router. \\\nEach line indicates that a node <code>node_id</code> has interfaces i<sub>1</sub> to i<sub>n</sub>. <br/>\n<strong>File format</strong>: node <node_id>: &nbsp; <i<sub>1</sub>&gt; &nbsp; <i<sub>2</sub>&gt; &nbsp; ... &nbsp; <i<sub>n</sub>&gt; <br/>\n~~~\nnode N1:  5.2.116.4 5.2.116.28 5.2.116.66 5.2.116.70 5.2.116.78 5.2.116.88 5.2.116.108 5.2.116.142\n~~~</p>\n\n<h4>midar-iff.links.bz2</h4>\n\n<p>The links file lists the set of routers and router interfaces that were inferred to be sharing each link. \\\nEach line indicates that a link <code>link_id</code> connects nodes N<sub>1</sub> to N<sub>m</sub>. \\\nIf it is known which router interface is connected to the link, then the interface address is given after the node ID separated by a colon.<br/>\n<strong>File format</strong>: link <link_id>: &nbsp; <N<sub>1</sub>&gt;:i<sub>1</sub> &nbsp;  <N<sub>2</sub>&gt;:i<sub>2</sub> &nbsp;  <N<sub>3</sub>&gt;:i<sub>3</sub> &nbsp;  ... &nbsp;  <N<sub>m</sub>&gt;:i<sub>m</sub> <br/>\n~~~\nlink L1: N27677807:1.0.0.1 N106961\n~~~</p>\n\n<h4>midar-iff.nodes.as.bz2</h4>\n\n<p>The node-AS file assigns an AS number to each node found in the nodes file.\\\n<strong>File format</strong>: node.AS   <node_id>   <AS>   <method>\n~~~\nnode.AS N1 31655 refinement\n~~~</p>\n\n<h4>midar-iff.nodes.geo.bz</h4>\n\n<p>The node-geolocation file contains the geographic location for each node in the nodes file.\\\n<strong>File format</strong>: node.geo   <node_id>:   <continent>   <country>   <region>   <city>   <latitude>   <longitude>\n~~~\nnode.geo N4: SA CO 34 Bogota 4.60971 -74.08175 <br />\n~~~</p>\n\n<p>More information on ITDK dataset can be found <a href=\"https://www.caida.org/data/request_user_info_forms/ark.xml\">here</a></p>\n",
        "context": "",
        "filename": "sources/solution/parse_the_itdk/Readme.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:how_to_annotate_a_traceroute_with_ixp": {
        "id": "solution:how_to_annotate_a_traceroute_with_ixp",
        "name": "How to Annotate a Traceroute with IXP",
        "description": "The following solution will return a list of IXP names given IP addresses",
        "tags": [
            "tag:ixps",
            "tag:internet_exchange_points",
            "tag:ip_address",
            "tag:ip"
        ],
        "content": "<h2>Solution</h2>\n\n<p>Given a list of IP addresses, this following solution will return a list of correseponding IXP names.</p>\n\n<p>load<em>traceroute() takes in one input:\n- <code>path</code>: Path to jsonl file of IXPs, which can be found here: <a href=\"https://www.caida.org/data/ixps/\">ixps dataset</a> under ixs</em>*.jsonl files</p>\n\n<p>and outputs:\n- <code>ixpdb</code>: pyasn database\n- <code>diction</code>: Dictionary to map to names of IXPs</p>\n\n<p>annotate_traceroute() takes in three inputs:</p>\n\n<ul>\n<li>List of IP addresses</li>\n<li><code>ixpdb</code>: pyasn database (from load_traceroute())</li>\n<li><code>diction</code>: Dictionary to map to names of IXPs (from load_traceroute())</li>\n<li><code>ips</code>: List of ip addresses</li>\n</ul>\n\n<p>and prints:\n- <code>final</code>: Array indicating corresponding IXP or invalid IP address note</p>\n\n<p><strong>Usage:</strong> <code>python3 ixp-annotations.py [path to jsonl file] [ip address] [ip address] ...</code></p>\n\n<p>i.e. <code>python3 ixp-annotations.py ixp.jsonl '198.32.231.77' '10'</code> will yield \n~~~\nInvalid IP:  10\n['npIX PTS', None]\n~~~</p>\n\n<p>~~~python</p>\n\n<p>import json\nimport numpy as np\nimport pyasn\nimport os</p>\n\n<p>def load<em>traceroute(path):\n    \"\"\"\n    Parses provided IXP dataset and creates a pyasn compatible database and dictionary to be used in the next function.\n    \"\"\"\n    temp</em>file = \"<em>ixp.dat\"\n    with open(path) as f:\n        next(f)\n        data = []\n        diction = {}\n        i = 1\n        # Gathers data from files and sets up format\n        for line in f:\n            obj = json.loads(line)\n            name = obj['name']\n            diction[i] = name\n            recorded</em>ipv4 = list(map(lambda x: x+\"\\t%d\"%i, obj['prefixes']['ipv4']))\n            recorded<em>ipv6 = list(map(lambda x: x+\"\\t%d\"%i, obj['prefixes']['ipv6']))\n            data+=(recorded</em>ipv4+recorded<em>ipv6)\n            i+=1\n        # Writes data into file\n        hdrtxt = '; IP-ASN32-DAT file\\n; Original file : <Path to a rib file>\\n; Converted on  : temp\\n; CIDRs         : 512490\\n;'\n        np.savetxt(temp</em>file, data, header=hdrtxt,fmt='%s')\n        ixpdb = pyasn.pyasn(temp<em>file)\n        # Removes created file\n        os.remove(temp</em>file)\n        return ixpdb, diction</p>\n\n<p>def annotate<em>traceroute(ixpdb, diction, ips):\n    \"\"\"\n    Inputs a path to data file and a list of IP addresses and returns a corresponding list of IXP names.\n    \"\"\"\n    # Converts all into IP address format, appends None if not IP address\n    ixp</em>list = [None]*len(ips)\n    for index in range(len(ips)):\n        # Checks if address is valid\n        try:\n            ixpdb.lookup(ips[index])\n        except ValueError:\n            print(\"Invalid IP: \", ips[index])\n            continue <br />\n        # Looks up IP address in IXP database\n        if ixpdb.lookup(ips[index])[1]:\n            ixp<em>list[index] = diction[ixpdb.lookup(ips[index])[0]]\n        else:\n            continue <br />\n    print(ixp</em>list)\n~~~</p>\n\n<h2>Background</h2>\n\n<h3>What is an Internet Exchange Point (IXP)?</h3>\n\n<ul>\n<li>An IXP is a physical infrastructure that allow Internet Service Providers (ISPs), Content Delivery Networks(CDNs), and other organizations to exchange Internet traffic between their networks</li>\n<li><a href=\"https://www.internetsociety.org/issues/ixps/\">IXPs are managed by one of the following</a>: non-profit organizations, associations of ISPs, operator-neutral for-profit companies, university or government agencies, informal associations of networks</li>\n</ul>\n\n<h3>What is an IP address?</h3>\n\n<ul>\n<li>IP addresses are unique identifiers that connect devices to the Internet network for communication purposes</li>\n</ul>\n\n<h3>What is a prefix?</h3>\n\n<ul>\n<li>An IP address has two sections: host and network</li>\n<li>The network section makes up the first portion and the host section makes up the seond</li>\n<li>Thus, each network address (prefix) consists of a number of unique host addresses</li>\n<li>The goal of this solution is to determine which IXP a host IP addresses belongs to through checking whether a host IP is within range of provided prefixes</li>\n</ul>\n\n<h3>Why use pyasn?</h3>\n\n<ul>\n<li>pyasn allows for quick lookups to determine whether an IP address is within a prefix</li>\n<li>For the purpose of this solution, we've used pyasn to match to a number corresponding to an IXP name of an IP address</li>\n</ul>\n\n<h2>Caveats</h2>\n\n<ul>\n<li>Requires permission to write files</li>\n</ul>\n",
        "context": "",
        "filename": "sources/solution/how_to_annotate_a_traceroute_with_ixp/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:how_to_get_the_range_of_allocated_or_reserved_asns": {
        "id": "solution:how_to_get_the_range_of_allocated_or_reserved_asns",
        "name": "How to get the range of allocated or reserved asns?",
        "description": "The following solution will create two dictionaries listing the ranges in which AS numbers: one compressed, one not compressed.",
        "question": "How to get the range of reserved and allocated ASNs",
        "tags": [
            "tag:asn",
            "tag:iana",
            "tag:autonomous_system"
        ],
        "content": "<h2>Solution</h2>\n\n<p>This solution will return two dictionaries - one compressed (with only allocated and reserved keys) and one with designations. </p>\n\n<p><strong>Usage</strong>: </p>\n\n<p>The function <code>iana_asn_asignee</code> inputs two dataframe paths - one for the IANA's 16-bit asn csv file and one for IANA's 32-bit asn csv file, and returns a dictionary with designation names. The function <code>iana_asn_compressed</code> returns a dictionary with all designations converted to \"allocated,\" revealing only the ranges of allocated and reserved numbers. </p>\n\n<p>These links will automatically download the current IANA ASN space registries:</p>\n\n<ul>\n<li>16-bit: https://www.iana.org/assignments/as-numbers/as-numbers-1.csv</li>\n<li>32-bit: https://www.iana.org/assignments/as-numbers/as-numbers-2.csv</li>\n</ul>\n\n<p><code>$ python3 current-asn.py [16-bit csv file path] [32-bit csv file path]</code></p>\n\n<p>~~~python \nimport pandas as pd\nimport argparse\nimport os</p>\n\n<p>def aggregate<em>ranges(ls):\n    \"\"\"\n    Helper function that aggregates consecutive lists of ranges into a single range.\n    \"\"\"\n    final = []\n    i = 0\n    if len(ls) == 1:\n        return ls\n    curr</em>range = ls[0]\n    while i != len(ls)-1:\n        i+=1\n        current = ls[i]\n        if ((curr<em>range[0] &lt;= current[1]) and (curr</em>range[0] &gt;= current[0])) or ((curr<em>range[0] &lt;= current[0]) and (curr</em>range[1] &gt;= current[0])):\n            curr<em>range = [min([curr</em>range[0], current[0]]), max([current[1], curr<em>range[1]])]\n            if i == len(ls)-1:\n                final.append(curr</em>range)\n                return final\n            continue\n            current = ls[i]\n        if (curr<em>range[1] + 1 == current[0]) or (curr</em>range[1] == current[0]):\n            curr<em>range[1] = current[1]\n            if i == len(ls)-1:\n                final.append(curr</em>range)\n                return final\n        else:\n            final.append(curr<em>range)\n            if i == len(ls)-1:\n                final.append(current)\n                return final\n            else:\n                curr</em>range = current\n    return final</p>\n\n<p>def simplify(x):\n    \"\"\"\n    Helper function returns either \"reserved\", \"unassigned\", or \"allocated\"\n    \"\"\"\n    if 'reserved' in x:\n        return 'reserved'\n    if 'unassigned' in x:\n        return 'unassigned'\n    else:\n        return 'allocated'</p>\n\n<p>def clean<em>designation</em>names(x):\n    \"\"\"\n    Helper function returns either \"reserved\", \"unassigned\", or \"allocated\"\n    \"\"\"\n    if 'reserved' in x:\n        return 'reserved'\n    if 'unassigned' in x:\n        return 'unassigned'\n    else:\n        return x.replace('assigned by', '').strip()</p>\n\n<p>def combine(csv<em>path16, csv</em>path32):\n    \"\"\"\n    Combines 16-bit and 32-bit csv files.\n    \"\"\" <br />\n    current<em>16 = pd.read</em>csv(csv<em>path16)\n    current</em>32 = pd.read<em>csv(csv</em>path32)\n    current<em>32 = current</em>32.loc[current<em>32[\"Number\"] != '0-65535']\n    return pd.concat([current</em>16, current_32])</p>\n\n<p>def iana<em>asn</em>asignees(csv<em>path16, csv</em>path32):\n    current = combine(csv<em>path16, csv</em>path32)\n    current[\"Description\"] = current[\"Description\"].apply(lambda x: clean<em>designation</em>names(x.lower()))\n    current[\"Number\"] = current[\"Number\"].apply(lambda x: [int(x), int(x)] if '-' not in x else [int(x.split('-')[0]), int(x.split('-')[1])])</p>\n\n<pre><code>asn = (current\n.drop(current.columns.difference(['Number','Description']), axis=1)\n.groupby(\"Description\")[\"Number\"]\n.apply(list)\n.apply(aggregate_ranges)).to_dict()\n\ntry:\n    del asn['unallocated']\nexcept KeyError:\n    pass\n\nreturn asn\n</code></pre>\n\n<p>def iana<em>asn</em>compressed(csv<em>path16, csv</em>path32): \n    current = combine(csv<em>path16, csv</em>path32)\n    current[\"Description\"] = current[\"Description\"].apply(lambda x: simplify(x.lower()))\n    current[\"Number\"] = current[\"Number\"].apply(lambda x: [int(x), int(x)] if '-' not in x else [int(x.split('-')[0]), int(x.split('-')[1])])</p>\n\n<pre><code>asn = (current\n.drop(current.columns.difference(['Number','Description']), axis=1)\n.groupby(\"Description\")[\"Number\"]\n.apply(list)\n.apply(aggregate_ranges)).to_dict()\n\ntry:\n    del asn['unallocated']\nexcept KeyError:\n    pass\n\nreturn asn\n</code></pre>\n\n<h1>print(iana<em>asn</em>asignees(csv1path, csv2path), iana<em>asn</em>compressed(csv1path, csv2path))</h1>\n\n<p>~~~</p>\n\n<h2>Background</h2>\n\n<h3>What is ASN?</h3>\n\n<ul>\n<li>ASN is short for autonomous system numbers</li>\n<li>ASNs are assigned to Autonomous Systems (AS), which are sub networks that amalgamate to form the Internet network</li>\n<li>Autonomous systems are allocated to unique ASN first through IANA, then through their region's Regional Internet Registry</li>\n<li>Information about the ASNs have been gathered from IANA, an organization that manages and records IP address and ASN allocations</li>\n</ul>\n\n<h2>Why are two files needed?</h2>\n\n<ul>\n<li>ASNs began as 16-bit numbers, meaning that there were previously only 65,000 unique numbers. In the early 2010s, a steady growth of the Internet network revealed the need for expansion. They thus began using 32-bits to allow for more unique numbers</li>\n<li>IANA currently formats the datasets so that 16-bit allocations are separate from 32-bit allocations. This solution will combine the two datasets to return all of the number ranges</li>\n<li>Note: The numbers are directly transferable as 32-bit allocations start from where the 16-bit allocations end</li>\n</ul>\n\n<h2>Caveats</h2>\n\n<ul>\n<li>This solution uses only the current datasets provided by IANA</li>\n<li>This solution combines the 16-bit and 32-bit csv files, so both must be provided</li>\n<li>You can access the </li>\n</ul>\n",
        "context": "",
        "filename": "sources/solution/how_to_get_the_range_of_allocated_or_reserved_asns/README.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "solution:solution_getting_an_asns_name_country_organization": {
        "id": "solution:solution_getting_an_asns_name_country_organization",
        "visibility": "public",
        "name": "How to get an ASN's name, organization and country?",
        "description": "Using the ASN's organization's country in WHOIS to map an ASN to the country of it's headquarters.",
        "tags": [
            "tag:measurement_methodology",
            "tag:topology",
            "tag:software_tools",
            "tag:asn",
            "tag:geolocation",
            "tag:organization",
            "tag:country"
        ],
        "content": "<h3><ins> Mapping ASN's to country </ins></h3>\n\n<p><em>AS to Organization Mapping Datasets:</em> <a href=\"https://www.caida.org/data/as-organizations/\">link</a></p>\n\n<p>One way to map a ASN to a country is by mapping to the <strong>country of its organization.</strong> </p>\n\n<p>The AS Organization files contain two different types of entries: AS numbers and\norganizations.\\\nThe two data types are divided by lines that start with\n'# format....'.\\\nAn example can be found below.\\\nNote: The <code>country</code> field is stored on the organization field format. </p>\n\n<p>Example of the AS organization in a test file:\n~~~</p>\n\n<h1>format: org<em>id|changed|org</em>name|country|source</h1>\n\n<p>LVLT-ARIN|20120130|Level 3 Communications, Inc.|US|ARIN</p>\n\n<h1>format: aut|changed|aut<em>name|org</em>id|opaque_id|source</h1>\n\n<p>1|20120224|LVLT-1|LVLT-ARIN|e5e3b9c13678dfc483fb1f819d70883c_ARIN|ARIN\n~~~</p>\n\n<h3>Explanation of the data fields</h3>\n\n<hr />\n\n<h2>Organization fields</h2>\n\n<p><strong>org_id</strong> : unique ID for the given organization \\\n <strong>changed</strong> : the changed date provided by its WHOIS entry \\\n <strong>name</strong>    : the name of the organization. The name could be selected from the AUT entry tied to the\n               organization, the AUT entry with the largest customer cone,\n               listed for the organization (if there existed an stand alone\n               organization), or a human maintained file. \\\n <strong>country</strong> : The country where the organization is located. Some WHOIS provide this field as a individual field. In other                cases we infer it from the addresses \\\n <strong>source</strong>  : the RIR or NIR database which contained this entry </p>\n\n<hr />\n\n<h2>AS fields</h2>\n\n<p><strong>aut</strong>     : the AS number or asn \\\n<strong>changed</strong> : the changed date provided by its WHOIS entry \\\n<strong>aut<em>name</strong> : the name provided for the individual AS number \\\n<strong>org</em>id</strong>  : maps to an organization entry \\\n<strong>opaque_id</strong>   : opaque identifier used by RIR extended delegation format \\\n<strong>source</strong>  : the RIR or NIR database which was contained this entry </p>\n\n<h3><ins> Solution </ins></h3>\n\n<p>The following script returns a dictionary <code>asn_info</code> that maps an ASN id to other field values <code>asn</code>, <code>changed</code>, <code>asn_name</code>, <code>org_id</code>, <code>source</code>, <code>org_name</code> and <code>country</code> in the following format:\\\n{'12285': {<code>asn</code>: '12285', <code>changed</code>: ' ', <code>asn_name</code>: ' ', \n<code>org_id</code>: ' ', <code>source</code>: '', <code>org_name</code>: ' ', <code>country</code>: ' ' }</p>\n\n<p>~~~python\nimport re\nimport sys</p>\n\n<p>re_format= re.compile(\"# format:(.+)\")</p>\n\n<p>org<em>info = {}\nasn</em>info = {}</p>\n\n<h1>Pass in test dataset as filename</h1>\n\n<p>with open(filename) as f:\n    for line in f:\n        m = re<em>format.search(line)\n        if m:\n            keys = m.group(1).rstrip().split(\",\")\n            keys = keys[0].split(\"|\")\n            if keys[0] == 'aut':\n                # Replace all instances of 'aut' with 'asn'\n                keys[0] = 'asn'\n                # Replace all instances of 'aut</em>name' with 'asn<em>name'\n                keys[2] = 'asn</em>name'</p>\n\n<pre><code>    # skips over comments\n    if len(line) == 0 or line[0] == \"#\":\n        continue\n\n    values = line.rstrip().split(\"|\")\n\n    info = {}\n\n    for i,key in enumerate(keys):\n        info[keys[i]] = values[i]\n\n\n    if \"asn\" == keys[0]:\n        org_id = info[\"org_id\"]\n        if org_id in org_info:\n            for key in [\"org_name\",\"country\"]:\n                info[key] = org_info[org_id][key]\n\n        asn_info[values[0]] = info\n\n    elif \"org_id\" == keys[0]:\n        org_info[values[0]] = info\n    else:\n        print (\"unknown type\",keys[0],file= sys.stderr)\n</code></pre>\n\n<h1>Contains the asn mapping to other field values in this format:</h1>\n\n<h1>{'12285': {'asn': '12285', 'changed': '20011231', 'asn_name': 'ONE-ELEVEN',</h1>\n\n<h1>'org<em>id': '111S-ARIN', 'source': 'ARIN', 'org</em>name': 'One Eleven Internet Services', 'country': 'US' }</h1>\n\n<h1>print(asn_info)</h1>\n\n<p>~~~</p>\n\n<h3><ins> Background </ins></h3>\n\n<p><strong>What is an AS?</strong>\\\n \u2022 AS stands for Autonomous system.\\\n \u2022 It can be broadly be thought of as a single organization, or a collection of routers that route groups of IP addresses under a common administration, typically a large organization or an ISP (Internet Service Provider). \\\n \u2022 It is a connected group of one or more IP addresses (known as IP prefixes) that provide a common way to route internet traffic to systems outside the AS.\\\n \u2022 Each AS is responsible for routing traffic within itself. This is known as intra-AS routing. \\\n \u2022 Each AS can also route traffic between itself and other autonomous systems. This is known as inter-AS routing. \\\n \u2022 More information on AS can be found <a href=\"https://www.cs.rutgers.edu/~pxk/352/notes/autonomous_systems.html\">here</a> and <a href=\"https://www.caida.org/publications/presentations/2016/as_intro_topology_wind/as_intro_topology_wind.pdf\">here</a></p>\n\n<p><strong>What is an ASN?</strong>\\\n    \u2022 Each AS is assigned a unique ASN, or <em>Autonomous System Number</em> that allows it to be uniquely identified during routing.</p>\n\n<p><strong>What is an ASN's organization?</strong>\\\n    \u2022 Each ASN can be mapped to a organization that controls multiple AS's over its network. </p>\n\n<p><strong>What is an ASN's country?</strong> \\\n    \u2022 The country where the ASN's organization is located. </p>\n\n<h3><ins> Caveats </ins></h3>\n\n<p>For Multi-National Corporations, or MNCs, (where multiple ASNs for the same organization are located in the same country or close neighboring countries) this ASN to country mapping would be an <strong>oversimplification</strong>, as the <code>country</code> would represent the ASN's headquarters but not the physical infrastructure. \nIn other words, the MNC ASN's will map back to the country where the headquarters are located, but not countries where all possible physical infrastucture is located. </p>\n",
        "context": "",
        "filename": "sources/solution/getting_an_asns_name_country_organization/Readme.md",
        "__typename": "Solution",
        "dateCreated": "2020/08/06 23:55:08",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:security": {
        "id": "tag:security",
        "filename": "sources/dataset/anycast_dataset.json",
        "__typename": "Tag",
        "name": "security",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:topology": {
        "id": "tag:topology",
        "filename": "sources/dataset/anycast_dataset.json",
        "__typename": "Tag",
        "name": "topology",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:anycast": {
        "id": "tag:anycast",
        "filename": "sources/dataset/anycast_dataset.json",
        "__typename": "Tag",
        "name": "anycast",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:active_measurement": {
        "id": "tag:active_measurement",
        "filename": "sources/dataset/archipelago.json",
        "__typename": "Tag",
        "name": "active measurement",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:file": {
        "id": "tag:file",
        "filename": "sources/dataset/archipelago.json",
        "__typename": "Tag",
        "name": "file",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ownership": {
        "id": "tag:ownership",
        "filename": "sources/dataset/as_organization.json",
        "__typename": "Tag",
        "name": "ownership",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:bgp": {
        "id": "tag:bgp",
        "filename": "sources/dataset/as_prefix.json",
        "__typename": "Tag",
        "name": "BGP",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:geolocation": {
        "id": "tag:geolocation",
        "filename": "sources/dataset/asrank.json",
        "__typename": "Tag",
        "name": "geolocation",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:routing": {
        "id": "tag:routing",
        "filename": "sources/dataset/bgpmon.json",
        "__typename": "Tag",
        "name": "routing",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:outages": {
        "id": "tag:outages",
        "filename": "sources/dataset/caida_ioda.json",
        "__typename": "Tag",
        "name": "outages",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:darknet": {
        "id": "tag:darknet",
        "filename": "sources/dataset/caida_ioda.json",
        "__typename": "Tag",
        "name": "darknet",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:visualization": {
        "id": "tag:visualization",
        "filename": "sources/dataset/caida_ioda.json",
        "__typename": "Tag",
        "name": "visualization",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ixp": {
        "id": "tag:ixp",
        "filename": "sources/dataset/euro_ix_ixp_service_matrix.json",
        "__typename": "Tag",
        "name": "ixp",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:asn": {
        "id": "tag:asn",
        "filename": "sources/dataset/iana_asn_allocations.json",
        "__typename": "Tag",
        "name": "asn",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:as_numbers": {
        "id": "tag:as_numbers",
        "filename": "sources/dataset/iana_asn_allocations.json",
        "__typename": "Tag",
        "name": "as numbers",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:iana": {
        "id": "tag:iana",
        "filename": "sources/dataset/iana_asn_allocations.json",
        "__typename": "Tag",
        "name": "iana",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:geographic": {
        "id": "tag:geographic",
        "filename": "sources/dataset/maxmind.json",
        "__typename": "Tag",
        "name": "geographic",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:weather": {
        "id": "tag:weather",
        "filename": "sources/dataset/thunderping.json",
        "__typename": "Tag",
        "name": "weather",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:software_tools": {
        "id": "tag:software_tools",
        "filename": "sources/group/asrank.json",
        "__typename": "Tag",
        "name": "software/tools",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:overview": {
        "id": "tag:overview",
        "filename": "sources/media/media:1998_caida_june98__placeholder.json",
        "__typename": "Tag",
        "name": "overview",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:measurement_methodology": {
        "id": "tag:measurement_methodology",
        "filename": "sources/media/media:1998_iepg_9808__placeholder.json",
        "__typename": "Tag",
        "name": "measurement methodology",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:caching": {
        "id": "tag:caching",
        "filename": "sources/media/media:1998_nanog9802__placeholder.json",
        "__typename": "Tag",
        "name": "caching",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:policy": {
        "id": "tag:policy",
        "filename": "sources/media/media:1999_soa9911__placeholder.json",
        "__typename": "Tag",
        "name": "policy",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:data": {
        "id": "tag:data",
        "filename": "sources/media/media:2000_darpa0010__placeholder.json",
        "__typename": "Tag",
        "name": "data",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:active_data_analysis": {
        "id": "tag:active_data_analysis",
        "filename": "sources/media/media:2000_isma00_brad__placeholder.json",
        "__typename": "Tag",
        "name": "active data analysis",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:dns": {
        "id": "tag:dns",
        "filename": "sources/media/media:2000_isma00_nevil__placeholder.json",
        "__typename": "Tag",
        "name": "dns",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:bandwidth_estimation": {
        "id": "tag:bandwidth_estimation",
        "filename": "sources/media/media:2001_bwestdb__placeholder.json",
        "__typename": "Tag",
        "name": "bandwidth estimation",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:passive_data_analysis": {
        "id": "tag:passive_data_analysis",
        "filename": "sources/media/media:2001_dns0701__placeholder.json",
        "__typename": "Tag",
        "name": "passive data analysis",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:network_telescope": {
        "id": "tag:network_telescope",
        "filename": "sources/media/media:2002_usenix_sec__placeholder.json",
        "__typename": "Tag",
        "name": "network telescope",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:internet_id_consumption": {
        "id": "tag:internet_id_consumption",
        "filename": "sources/media/media:2005_arin__placeholder.json",
        "__typename": "Tag",
        "name": "internet id consumption",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:ipv6": {
        "id": "tag:ipv6",
        "filename": "sources/media/media:2005_caidawide050311_as_topology__placeholder.json",
        "__typename": "Tag",
        "name": "ipv6",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:peer_to_peer": {
        "id": "tag:peer_to_peer",
        "filename": "sources/media/media:2005_oida2005_06__placeholder.json",
        "__typename": "Tag",
        "name": "peer-to-peer",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:trends": {
        "id": "tag:trends",
        "filename": "sources/media/media:2008_wide_huffaker_ipv6_survey__placeholder.json",
        "__typename": "Tag",
        "name": "trends",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:network_geometry": {
        "id": "tag:network_geometry",
        "filename": "sources/media/media:2010_ccnr_metric_spaces_bipartite__placeholder.json",
        "__typename": "Tag",
        "name": "network geometry",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:economics": {
        "id": "tag:economics",
        "filename": "sources/media/media:2010_economics_interconnections__placeholder.json",
        "__typename": "Tag",
        "name": "economics",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:internet_outages": {
        "id": "tag:internet_outages",
        "filename": "sources/media/media:2012_analysis_darknets_badgers__placeholder.json",
        "__typename": "Tag",
        "name": "internet outages",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:congestion": {
        "id": "tag:congestion",
        "filename": "sources/media/media:2014_bitag_congestion__placeholder.json",
        "__typename": "Tag",
        "name": "congestion",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:qoe": {
        "id": "tag:qoe",
        "filename": "sources/media/media:2017_crowdtrace_aims__placeholder.json",
        "__typename": "Tag",
        "name": "QoE",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:data_sharing": {
        "id": "tag:data_sharing",
        "filename": "sources/media/media:2017_hi_cube_hub__placeholder.json",
        "__typename": "Tag",
        "name": "data sharing",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:education": {
        "id": "tag:education",
        "filename": "sources/media/media:2018_hyperpapers_open_coauthoring_aims__placeholder.json",
        "__typename": "Tag",
        "name": "education",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:mobile": {
        "id": "tag:mobile",
        "filename": "sources/media/media:2019_empirical_study_mobile_network_behavior_iwqos__placeholder.json",
        "__typename": "Tag",
        "name": "mobile",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:ipv4": {
        "id": "tag:ipv4",
        "filename": "sources/media/ipv4_history_viz_interactive.json",
        "__typename": "Tag",
        "name": "ipv4",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:sankey": {
        "id": "tag:sankey",
        "filename": "sources/media/ipv4_history_viz_interactive.json",
        "__typename": "Tag",
        "name": "sankey",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:presentation": {
        "id": "tag:presentation",
        "filename": "sources/media/ipv4_history_viz_interactive.json",
        "__typename": "Tag",
        "name": "presentation",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:url": {
        "id": "tag:url",
        "filename": "sources/media/ipv4_history_viz_interactive.json",
        "__typename": "Tag",
        "name": "url",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:video": {
        "id": "tag:video",
        "filename": "sources/media/ipv4_history_viz_video.json",
        "__typename": "Tag",
        "name": "video",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "author:luckie_matthew": {
        "id": "author:luckie_matthew",
        "filename": "sources/media/network_hygiene_incentives_and_regulation_deployment_of_source_address_validation_in_the_internet.json",
        "__typename": "Author",
        "name": "Luckie Matthew",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:workshop_report": {
        "id": "tag:workshop_report",
        "filename": "sources/paper/paper:1999_isma9901__placeholder.json",
        "__typename": "Tag",
        "name": "workshop report",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:autocracy": {
        "id": "tag:autocracy",
        "filename": "sources/paper/2019_at_home_and_abroad_the_use_of_denial_of_service_attacks_during_elections_in_nondemocratic_regimes.json",
        "__typename": "Tag",
        "name": "autocracy",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:digital_politics": {
        "id": "tag:digital_politics",
        "filename": "sources/paper/2019_at_home_and_abroad_the_use_of_denial_of_service_attacks_during_elections_in_nondemocratic_regimes.json",
        "__typename": "Tag",
        "name": "digital politics",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:internet_measurement": {
        "id": "tag:internet_measurement",
        "filename": "sources/paper/2019_at_home_and_abroad_the_use_of_denial_of_service_attacks_during_elections_in_nondemocratic_regimes.json",
        "__typename": "Tag",
        "name": "Internet measurement",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:cyberattacks": {
        "id": "tag:cyberattacks",
        "filename": "sources/paper/2019_at_home_and_abroad_the_use_of_denial_of_service_attacks_during_elections_in_nondemocratic_regimes.json",
        "__typename": "Tag",
        "name": "cyberattacks",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:internet_reliability": {
        "id": "tag:internet_reliability",
        "filename": "sources/paper/2019_residential_links_under_the_weather.json",
        "__typename": "Tag",
        "name": "Internet reliability",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:ping": {
        "id": "tag:ping",
        "filename": "sources/paper/2019_residential_links_under_the_weather.json",
        "__typename": "Tag",
        "name": "ping",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:remote_peering": {
        "id": "tag:remote_peering",
        "filename": "sources/paper/2019_towards_passive_analysis_of_anycast_in_global_routing_unintended_impact_of_remote_peering.json",
        "__typename": "Tag",
        "name": "Remote Peering",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:peering": {
        "id": "tag:peering",
        "filename": "sources/paper/2019_towards_passive_analysis_of_anycast_in_global_routing_unintended_impact_of_remote_peering.json",
        "__typename": "Tag",
        "name": "Peering",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:internet_routing": {
        "id": "tag:internet_routing",
        "filename": "sources/paper/2019_towards_passive_analysis_of_anycast_in_global_routing_unintended_impact_of_remote_peering.json",
        "__typename": "Tag",
        "name": "Internet Routing",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 17:34:56",
        "date": "2020/08/06 17:34:56"
    },
    "tag:hijack_detection": {
        "id": "tag:hijack_detection",
        "filename": "sources/software/artemis.json",
        "__typename": "Tag",
        "name": "hijack detection",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:bsd_3_clause": {
        "id": "license:bsd_3_clause",
        "name": "bsd_3_clause",
        "filename": "sources/software/artemis.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 23:32:14",
        "dateLastUpdated": "2020/08/06 23:32:14",
        "date": "2020/08/06 23:32:14"
    },
    "tag:ui": {
        "id": "tag:ui",
        "filename": "sources/software/as_relationship.json",
        "__typename": "Tag",
        "name": "UI",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:api": {
        "id": "tag:api",
        "filename": "sources/software/asrank_api.json",
        "__typename": "Tag",
        "name": "API",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:traffic": {
        "id": "tag:traffic",
        "filename": "sources/software/coralreef.json",
        "__typename": "Tag",
        "name": "traffic",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ip_address": {
        "id": "tag:ip_address",
        "filename": "sources/software/iffinder.json",
        "__typename": "Tag",
        "name": "ip address",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:alias_resolution": {
        "id": "tag:alias_resolution",
        "filename": "sources/software/iffinder.json",
        "__typename": "Tag",
        "name": "alias resolution",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:gnu_general_public_license_version_2": {
        "id": "license:gnu_general_public_license_version_2",
        "name": "GNU GENERAL PUBLIC LICENSE Version 2",
        "filename": "sources/software/kapar.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 23:32:14",
        "dateLastUpdated": "2020/08/06 23:32:14",
        "date": "2020/08/06 23:32:14"
    },
    "tag:library": {
        "id": "tag:library",
        "filename": "sources/software/libtimeseries.json",
        "__typename": "Tag",
        "name": "library",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:database": {
        "id": "tag:database",
        "filename": "sources/software/libtimeseries.json",
        "__typename": "Tag",
        "name": "database",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:bsd_2_clause": {
        "id": "license:bsd_2_clause",
        "name": "bsd_2_clause",
        "filename": "sources/software/libtimeseries.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 23:32:14",
        "dateLastUpdated": "2020/08/06 23:32:14",
        "date": "2020/08/06 23:32:14"
    },
    "tag:interdomain_links": {
        "id": "tag:interdomain_links",
        "filename": "sources/software/manic.json",
        "__typename": "Tag",
        "name": "interdomain links",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ip_links": {
        "id": "tag:ip_links",
        "filename": "sources/software/manic.json",
        "__typename": "Tag",
        "name": "IP links",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:web": {
        "id": "tag:web",
        "filename": "sources/software/netacuity.json",
        "__typename": "Tag",
        "name": "WEB",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ipv4_adddress": {
        "id": "tag:ipv4_adddress",
        "filename": "sources/software/pyasn.json",
        "__typename": "Tag",
        "name": "IPv4 adddress",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:code": {
        "id": "tag:code",
        "filename": "sources/software/pyasn.json",
        "__typename": "Tag",
        "name": "CODE",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:performance_measurement": {
        "id": "tag:performance_measurement",
        "filename": "sources/software/scamper.json",
        "__typename": "Tag",
        "name": "performance measurement",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "license:gnu_general_public_license_version_3": {
        "id": "license:gnu_general_public_license_version_3",
        "name": "GNU GENERAL PUBLIC LICENSE Version 3",
        "filename": "sources/software/spoofer.json",
        "__typename": "License",
        "dateCreated": "2020/08/06 23:32:14",
        "dateLastUpdated": "2020/08/06 23:32:14",
        "date": "2020/08/06 23:32:14"
    },
    "tag:traceroute": {
        "id": "tag:traceroute",
        "filename": "sources/software/vela.json",
        "__typename": "Tag",
        "name": "traceroute",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ark": {
        "id": "tag:ark",
        "filename": "sources/software/vela.json",
        "__typename": "Tag",
        "name": "ark",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ipv4_prefix": {
        "id": "tag:ipv4_prefix",
        "filename": "sources/solution/map_ipv4_address_to_asn/README.md",
        "__typename": "Tag",
        "name": "ipv4 prefix",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:as_relationship": {
        "id": "tag:as_relationship",
        "filename": "sources/solution/how_to_find_the_business_relationships_between_asns/README.md",
        "__typename": "Tag",
        "name": "as relationship",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:as_rank": {
        "id": "tag:as_rank",
        "filename": "sources/solution/how_to_find_the_business_relationships_between_asns/README.md",
        "__typename": "Tag",
        "name": "as rank",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/07 18:55:59",
        "date": "2020/08/07 18:55:59"
    },
    "tag:bogon": {
        "id": "tag:bogon",
        "filename": "sources/solution/how_to_parse_cymru_bogon_data/README.md",
        "__typename": "Tag",
        "name": "bogon",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:bogon_address": {
        "id": "tag:bogon_address",
        "filename": "sources/solution/how_to_parse_cymru_bogon_data/README.md",
        "__typename": "Tag",
        "name": "bogon address",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:ip": {
        "id": "tag:ip",
        "filename": "sources/solution/how_to_parse_cymru_bogon_data/README.md",
        "__typename": "Tag",
        "name": "ip",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:as_relationships": {
        "id": "tag:as_relationships",
        "filename": "sources/solution/how_to_find_an_asns_customer_cone/README.md",
        "__typename": "Tag",
        "name": "as relationships",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:customer_cone": {
        "id": "tag:customer_cone",
        "filename": "sources/solution/how_to_find_an_asns_customer_cone/README.md",
        "__typename": "Tag",
        "name": "customer cone",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:ixps": {
        "id": "tag:ixps",
        "filename": "sources/solution/how_to_annotate_a_traceroute_with_ixp/README.md",
        "__typename": "Tag",
        "name": "ixps",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:internet_exchange_points": {
        "id": "tag:internet_exchange_points",
        "filename": "sources/solution/how_to_annotate_a_traceroute_with_ixp/README.md",
        "__typename": "Tag",
        "name": "internet exchange points",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:autonomous_system": {
        "id": "tag:autonomous_system",
        "filename": "sources/solution/how_to_get_the_range_of_allocated_or_reserved_asns/README.md",
        "__typename": "Tag",
        "name": "autonomous system",
        "dateCreated": "2020/08/07 16:35:37",
        "dateLastUpdated": "2020/08/07 16:35:37",
        "date": "2020/08/07 16:35:37"
    },
    "tag:organization": {
        "id": "tag:organization",
        "filename": "sources/solution/getting_an_asns_name_country_organization/Readme.md",
        "__typename": "Tag",
        "name": "organization",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    },
    "tag:country": {
        "id": "tag:country",
        "filename": "sources/solution/getting_an_asns_name_country_organization/Readme.md",
        "__typename": "Tag",
        "name": "country",
        "dateCreated": "2020/08/06 15:27:16",
        "dateLastUpdated": "2020/08/06 15:27:16",
        "date": "2020/08/06 15:27:16"
    }
}